# 02. 끝말잇기

## 02-01. React Hooks 사용하기

기존 class 방식

```javascript
class Gugudan extends React.Component{
    ...
}
```

Functional Component

```javascript
// 안에 setState, ref를 할 필요가 없을 때 사용.
const Gugudan = () =>{
    return <div>Hello, Hooks</div>
}
```



함수 컴포넌트에서도 ref와 state를 쓸 수있게 해주는게 `Hooks`다.

class보다 코드도 더 간결해져서 React도 Hooks쓰는 걸 권장한다.

```javascript
const GuGuDan = () =>{
    this.state = {
        value: '',
        first: '',
        second: '',
    };
}
```

위 같이 선언은 불가능.

아래처럼 하나씩 선언하고, useState안에 초기값을 설정해준다.

```javascript
const GuGuDan = () =>{
    const [first, setFirst] = React.useState(Math.ceil(Math.random()*9))
    const [second, setSecond] = React.useState(Math.ceil(Math.random()*9))
    const [value, setValue] = React.useState('')
    const [result, setResult] = React.useState('')
}
```

❗ 안에 선언한 것을 컴포넌트 밖으로 빼면 안된다!.

use가 붙은 것들이 다 hooks다.

class로 작성된 부분을 수정해보자.

```javascript
const GuGuDan = () =>{
    const [first, setFirst] = React.useState(Math.ceil(Math.random()*9))
    const [second, setSecond] = React.useState(Math.ceil(Math.random()*9))
    const [value, setValue] = React.useState('')
    const [result, setResult] = React.useState('')

    return (
    <React.Fragment>
        <div>{first} 곱하기 {second}는?</div>
        <form>
            <input value={value} />
	        <button>입력</button>
        </form>
        <div id="result">{result}</div>
    </React.Fragment>
	)
}
```



여기서 이제 이벤트를 추가해보자.

onChangeInput 메서드를 생성하고, e.target.value를 setValue를 이용해 넣어 줄 수 있다.

ref의 경우 `React.useRef`를 이용해 변수를 선언하고, focus시 current를 추가해 접근하여 사용할 수 있다.

```javascript
<html>
  <head>
    <meta charset="utf-8" />
    <title>GuGuDan</title>
  </head>
  <body>
...
    <script type="text/babel">
      const GuGuDan = () =>{
        const [first, setFirst] = React.useState(Math.ceil(Math.random()*9))
        const [second, setSecond] = React.useState(Math.ceil(Math.random()*9))
        const [value, setValue] = React.useState('')
        const [result, setResult] = React.useState('')
        const inputEl = React.useRef(null);
        const onChangeInput = (e) =>{
          setValue(e.target.value);
        }
        const onSubmitForm = (e) => {
          e.preventDefault();
          // 구구단 로직
          if (parseInt(value) ===first * second) {
            setResult(`정답 : ${value}`)
            setFirst(Math.ceil(Math.random()*9))
            setSecond(Math.ceil(Math.random()*9))
            setValue('');
            this.inputEl.current.focus();
          } else {
            setResult(`땡`)
            setValue('');
            this.inputEl.current.focus();
          }

        }
        return (
          <React.Fragment>
            <div>{first} 곱하기 {second}는?</div>
            <form onSubmit={onSubmitForm}>
              <input ref={inputEl} onChange={onChangeInput} value={value}/>
              <button>입력</button>
            </form>
            <div id="result">{result}</div>
          </React.Fragment>
        );
      }
    </script>
    <script type="text/babel">
      ReactDOM.createRoot(document.querySelector("#root")).render(<GuGuDan />);
    </script>
  </body>
</html>

```





## 02-02. Class와 Hooks 비교하기

Hooks가 코드가 더 짧은걸 볼 수 있다.

> ❗ Render 차이
>
> Hooks는 state가 바뀔때 똑같이 바뀌는데 함수전체가 다시 실행되기때문에 조금 더 느릴 수 있다.
>
> class는 render함수만 재실행함.<br/>
>
> setState를 모아서 비동기로 한번에 처리하기 때문에 setState를 4번썻다고 4번 렌더되지 않는다.



React는 html작성부분에 class를 쓸 수 없다.

그래서 class대신에 className을 사용해야한다.

label의 for는 labelFor로 변경.



useState를 객체형으로 써도 되긴하지만, setState시에 불편함이 발생한다.

객체중 일부를 바꾸지만, 객체 전체를 작성해준다던가 등...



setState에서도 함수형으로 작성해 과거 값을 사용할 수 있다.

```javascript
setResult((prevResult)=> {return `정답 : ${prevResult}`})
```

