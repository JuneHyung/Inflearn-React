# 03. 숫자 야구

## 03-01. import와 require

**require**

node의 모듈 시스템.

export한 모듈을 다른 파일에서 require로 불러 올 수 있다.

exports 되는게 객체나 배열이면 구조 분해가 가능.



**import 시 차이**

export시 default로 export하면 => `import ㅇㅇㅇ`

export시 default가 아니면 => `import { ㅇㅇㅇ }`

형태로 가져온다. 

엄밀히 따지자면, module.exports와 export default는 다르지만, 호환은 된다.



webpack에서는 node에서 실행되기 때문에 import사용하면, 에러나고 require를 써야한다.

client부분에서는 import를 쓸 수 있는데 webpack의 바벨이 변환 해주기 때문이다.



## 03-02. 리액트 반복문 (map)

숫자야구를 만들어 보자.

언제나 바뀌는 부분과 바뀌지않는 부분을 파악!

우선 webpack과 react, reactdom 설치

```shell
npm i react react-dom
npm i -D webpack webpack-cli
```

```jsx
// NumberBaseballClass.jsx
import React, {Component} from 'react';

function getNumbers(){ // 숫자 4개를 랜덤하게 뽑는 함수

}

class NumberBaseball extends Component{
  state = {
    result: '',
    value: '',
    answer: getNumbers(),
    tries:[],
  };

  onSubmitForm = () =>{

  };
  onChangeINput = () =>{

  }
  render(){
    return{
      <>
        <h1>{this.state.result}</h1>
        <form onSubmit={this.onSubmitForm}>
          <input maxLength={4} value={this.state.value} onChange={this.onChangeInput}/>
        </form>
        <div>시도 : {this.state.tries.length}</div>
        <ul>
          <li />
        </ul>
      </>
    };
  }
}
```

onSubmit과 onChangeInput처럼 custom하는 메소드들은 화살표 함수를 사용해야 constructor를 만들어주지 않고 사용이 가능하다.



li부분에서 map과 props를 사용해 볼 것이다.

map은 React에서 반복문을 쓰는 방법. (js의 map함수생각하면 된다.)

```jsx
<ul>
    {['사과', '바나나', '포도', '귤'].map((el)=>{
        return (
            <li>{el}</li>
        )
    })}
</ul>
```



## 03-03. 리액트 반복문(key)

* **사과** - 맛있다
* **바나나** -맛없다
* **포도** - 시다
* **귤** - 떫다

위 결과를  반복문으로 만들어 보자.

**배열을 2차원 배열로 만드는 방법.**

```jsx
<ul>
    {[['사과', '맛있다'], ['바나나', '맛없다'], ['포도', '시다'], ['귤','떫다']].map((el)=>{
        return (
            <li><b>{el[0]}</b> - {el[1]}</li>
        )
    })}
</ul>
```



**값을 객체 형태로 만드는 방법.**

```jsx
<ul>
    {[
        {fruit: '사과', taste: '맛있다'}, 
        {fruit: '바나나', taste: ' 맛없다'}, 
        {fruit: '포도', taste:'시다'}, 
        {fruit: '귤', taste: '떫다'}
    ].map((el)=>{
        return (
            <li><b>{el.fruit}</b> - {el.taste}</li>
        )
    })}
</ul>
```



반복문 돌리는게 가독성이 떨어진다고 생각할 수 있다. => 가독성 좋게, 성능적으로도 상향시켜주는게 **props**

> **주의❗ 반복문을 돌릴 때 항상 key를 추가해주어야한다.**
>
> 리액트가 key를 보고 같은 컴포넌트인지 아닌지 판단함.
>
> 
>
> ❗ i가 고유하기 때문에 i만 키로 사용할 수도 있는데, 성능최적화 문제가 있을 수 있다.
>
> 차라리 `이름 + i`형태로 사용하고, 되도록 구분할 수 있는 고유한 값으로 설정하기!!!
>
> => 리액트가 key를 보고 컴포넌트를 찾는데 알아보기가 힘들어진다. (추후 설명)
>
> ```jsx
> <ul>
>     {['사과', '바나나', '포도', '귤'].map((v, i)=>{
>         return (
>             <li key={v.fruit + v.taste + i}><b>{v}</b> - {}</li>
>         )
>     })}
> </ul>
> ```



❗ 화살표함수는 리턴을 생략할 수 있다.

```jsx
<ul>
    {['사과', '바나나', '포도', '귤'].map((v)=>(
            <li key={v.fruit + v.taste}><b>{v}</b> - {}</li>
        )
    )}
</ul>
```





## 03-04. 컴포넌트 분리와 props

우선 가독성을 위해 배열을 밖으로 이동!

```jsx
...
class NumberBaseball extends Component {
  ...
  fruits = [
    { fruit: "사과", taste: "맛있다" },
    { fruit: "바나나", taste: " 맛없다" },
    { fruit: "포도", taste: "시다" },
    { fruit: "귤", taste: "떫다" },
  ]
  render() {
    return (
      <>
        <h1>{this.state.result}</h1>
        <form onSubmit={this.onSubmitForm}>
          <input maxLength={4} value={this.state.value} onChange={this.onChangeInput}/>
        </form>
        <div>시도 : {this.state.tries.length}</div>
        <ul>
          {this.fruits.map((el, i) => {
            return (
              <li key={el.fruit + el.taste + i}>
                <b>{el.fruit}</b> - {el.taste}
              </li>
            );
          })}
        </ul>
      </>
    );
  }
}
```

지금은 반복되는 li가 간단하지만, 좀 더 복잡해질 수 있다.

그렇기 때문에 다른 파일로 분리.

```jsx
// Try.jsx
import React, {Component} from 'react';

class Try extends Component{
  render(){
    return (
      <li key={el.fruit + el.taste + i}>
        <b>{el.fruit}</b> - {el.taste}
      </li>

    )
  }
}

export default Try;
```

```jsx
// NumberBaseballClass.jsx
...
import Try from './Try.jsx';
class NumberBaseball extends Component {
  ...
  render() {
    return (
      <>
        <h1>{this.state.result}</h1>
        <form onSubmit={this.onSubmitForm}>
          <input maxLength={4} value={this.state.value} onChange={this.onChangeInput} />
        </form>
        <div>시도 : {this.state.tries.length}</div>
        <ul>
          {this.fruits.map((el, i) => {
            return (
              <Try />
            );
          })}
        </ul>
      </>
    );
  }
}

```

**따로 빼는 이유?**

* 코드 관리
* 반복문에서 성능문제가 많이 발생하기 때문도 있다. => 추후 최적화에서 설명.
* 재사용성
* 가독성



여기서 문제!

Try로 바꾸면서 list의 정보가 Try에 전달이 안된다.

=> Try에 전달해주는 방법이 바로 **Props**

html의 attribute들 처럼 사용하면된다.

(익숙하지 않다면, 일단 한 파일에 다 작성 후 컴포넌트 분리를 진행하자.)

```jsx
<ul>
    {this.fruits.map((el, i) => {
        return (
            <Try  key={el.fruit + el.tasete} value={el} index={i}/>
        );
    })}
</ul>
```

```jsx
// Try.jsx
import React, {Component} from 'react';

class Try extends Component{
  render(){
    return (
      <li>
        <b>{this.props.value.fruit}</b> - {this.props.value.taste}
      </li>

    )
  }
}

export default Try;
```





## 03-05. 주석과 메서드 바인딩

잊지말자. map을 사용하면 반드시 key를 지정해주어야 한다.

나중엔 depth가 깊어지면 1 -2 -3일때 1에서 3으로 전달해야 하는 경우가 생길 수 있다.

이런 경우를 위해 사용하는 것이 redux나 context등이다.



주석에 대해 알아보자.

Javascript는 `//거나 /* 내용 */`.

React에서는 `{/* 내용 */}`이렇게 블록주석에 {}로 감싸주어야한다.



**custom function**

위에서 화살표 함수를 써야한다고 했었다.

**만약 화살표함수를 안쓰게 되면, this.state를 못쓰게 된다.**

```jsx
onChangeInput(e){
    this.setState({
        value:e.target.value
    })
}
// setState가 undefined라고 에러가 발생.
```



만약 위 형태처럼 쓰고 싶다면?

costructor를 써야한다.

```jsx
class NumberBaseball extends Component {
  constructor(props){
    super(props);
	this.state = {
        result: "",
        value: "",
        answer: getNumbers(),
        tries: [],
    };
    this.onChangeInput = this.onChangeInput.bind(this);
  }
  onChangeInput(e){
      this.setState({
          value:e.target.value
      })
  }
}
```

왜 써줘야할까?

onChangeInput에 this를 출력해보면 알 수 있다.

bind(this)를 하게 되면, onChangeInput에서 this가 state나 props등 정보가 담겨 있다.

하지만 써주지 않으면, undefined가 출력된다.

문법이 바뀌면서 쓰지는 않게 됐지만, 사용방법이 다양하니까 알아는 두자.





## 03-06. 숫자야구 만들기

먼저 getNumbers작성.

```jsx
function getNumbers() {
  // 숫자 4개를 랜덤하게 뽑는 함수
  const candidate = [1,2,3,4,5,6,7,8,9];
  const arr = [];
  for(let i=0;i<4;i+=1){
    const chosen = candidate.splice(Math.floor(Math.random() * (9-i), 1))[0];
    arr.push(chosen);
  }
  return arr;
}
```

onChangeInput

```jsx
onChangeInput = (e) => {
    this.setState({
        value: e.target.value,
    })
};
```



정답이 맞는지 확인하는 onSubmitForm() 작성

맞는 경우 result는 '홈런!'이 되고, tries에 시도를 추가. 그 후 초기화.

틀린 경우 몇Strike 몇 Ball인지. 10번 넘으면 초기화

```jsx
onSubmitForm = (e) => {
    e.preventDefault();
    if(this.state.value=== this.state.answer.join('')){
      this.setState({
        result: '홈런!',
        tries: [...this.state.tries, {try: this.state.value, result: '홈런'}],
      })
      alert('게임을 다시 시작합니다!');
        this.setState({
          value:'',
          answer: getNumbers(),
          tries: [],
        });
    }
    else{
      const answerArray = this.state.value.split('').map((v)=>parseInt(v));
      let strike = 0;
      let ball = 0;
      if(this.state.tries.length >=9){
        this.state.setState({
          result: `10번 넘게 틀려서 실패! 답은 ${answer.join('')} 이였습니다!`,
        });
        alert('게임을 다시 시작합니다!');
        this.setState({
          value:'',
          answer: getNumbers(),
          tries: [],
        });
      }else{
        for(let i=0;i<4;i+=1){
          if(answerArray[i] === this.state.answer[i]){
            strike+=1;
          }else if(this.state.answer.includes(answerArray[i])){
            ball+=1;
          }
          this.setSttate({
            tries: [...this.state.tries, {try: this.state.value, result: `${strike} 스트라이크, ${ball} 볼 입니다.`}]
          })
        }
      }
    }
  };
```

❗ push를 쓰면, 뭐가 바뀌었는지 감지를 못한다.

=> 새로운 배열을 만들어 set해주어야한다. (위의 경우 기존값 + 새로운 값을 넣어준것이다.)

**why?** 

기존과 새로운것이 다르기 때문.

리액트가 렌더링하는 기준이 예전 state와 현재 state가 다르면 렌더링을 한다. => 참조가 바뀌어야 한다.

push하면? => 참조가 바뀌지 않는다.



render부분과 Try컴포넌트에 배열 변경.

```jsx
// NumberBaseballClass.jsx
render() {
    return (
      <>
        <h1>{this.state.result}</h1>
        <form onSubmit={this.onSubmitForm}>
          <input maxLength={4} value={this.state.value} onChange={this.onChangeInput}/>
        </form>
        <div>시도 : {this.state.tries.length}</div>
        <ul>
          {this.state.tries.map((el, i) => {
            return (
              <Try key={`${i+1}차 시도 : `} tryInfo={el} index={i}/>
            );
          })}
        </ul>
      </>
    );
  }
```

```jsx
// Try.jsx
import React, {Component} from 'react';

class Try extends Component{
  render(){
    return (
      <li>
        <div>{this.props.tryInfo.try}</div>
        <div>{this.props.tryInfo.result}</div>
      </li>
    )
  }
}

export default Try;
```





## 03-07. Q&A

Q. this.state가 번거로운거 같다.

A. 비구조화 할당을 통해 해결 할 수 있다 

```jsx
render() {
    const {result, value, tries} = this.state;
    return (
      <>
        <h1>{this.state.result}</h1>
        <form onSubmit={this.onSubmitForm}>
          <input maxLength={4} value={value} onChange={this.onChangeInput}>
        </form>
        <div>시도 : {this.state.tries.length}</div>
        <ul>
          {this.state.tries.map((el, i) => {
            return (
              <Try key={`${i+1}차 시도 : `} tryInfo={el} index={i}/>
            );
          })}
        </ul>
      </>
    );
  }
```

props도 똑같다.

```jsx
// try.jsx
import React, {Component} from 'react';

class Try extends Component{
  render(){
    const {tryInfo} = this.props;
    return (
      <li>
        <div>{tryInfo.try}</div>
        <div>{tryInfo.result}</div>
      </li>
    )
  }
}

export default Try;
```



Q. 언제 메서드를 밖으로 빼고, 안으로 넣는가?

A. 다 안에 넣어도 되지만, this를 안쓰는 경우 밖으로 뺄 수 있다.

밖으로 빼면, 메서드가 다른 곳에서 쓰일 수 있는데 안에 있는 경우, 쓰는데 어려움이 있다.

큰 차이는 없지만, 다른 곳에서도 사용하고, this를 쓰지않는경우 밖으로 뺄 수 있다.