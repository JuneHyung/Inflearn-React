# 06. 로또 추첨기

## 06-01. 로또 추첨기 컴포넌트

자동으로 숫자6개와 보너스 숫자 뽑는 컴포넌트.

> ❗ 시작하기전에.
>
> Q. setInterval을 useEffect에서만 써야되는가?
>
> A. render가 아닌 필요한곳에서 사용해도 상관없는데, componentWillUnmount에서 clearInterval만 해주면 된다.

시작해보자.

```jsx
import React, {Component} from 'react';
function getWinNumbers() { // 숫자 7개를 미리 뽑는 함수
  console.log('getWinNumbers')
  const candidate = Array.fill().map((v,i)=>i+1);
  const shuffle = [];
  while(candidate.length > 0){
    shuffle.push(candidate.splice(Math.floor(Math.random()*candidate.length), 1)[0])
  }
  const bonusNumber=  shuffle[shuffle.length-1];
  const winNumbers = shuffle.slice(0, 6).sort((p, c)=>p-c);
  return [...winNumbers, bonusNumber];
}
class Lotto extends Component{
  state = {
    winNumbers: getWinNumbers(), // 당첨 숫자들
    winBalls: [],
    bonus: null, // 보너스 공
    redo: false,
  };
  render(){
    const {winBalls, bonus, redo} = this.state;
    return (
      <>
        <div>당첨 숫자</div>
        <div id="결과창">
          {winBalls.map((v)=> <Ball key={v} number={v} />)}
        </div>
        <div>보너스</div>
        {bonus && <Ball number={bonus} />}
        <button onClick={redo ? this.onClickRedo : ()=>{}}>한 번 더!</button>
      </>
    )
  }
}
```

Ball이 반복되니 컴포넌트로 따로 뺄 것이다.

보통 가장 아래의 위치의 컴포넌트는 pureComponent를 쓴다.

```jsx
import React, { memo } from "react";

const Ball = memo(({ number }) => {
  const { number } = this.props;
  let background;
  if (number <= 10) {
    background = "red";
  } else if (number <= 20) {
    background = "orange";
  } else if (number <= 30) {
    background = "yellow";
  } else if (number <= 40) {
    background = "blue";
  } else {
    background = "green";
  }

  return (
    <div className="ball" style={{ background }}>{number}</div>
  );
});
export default Ball;
```





## 06-02. setTimeout 여러 번 사용하기

시작하자마자 번호가 하나씩 뜨게 할 것이다. => componentDidMount

버튼이 보너스까지 다뜨면 redo를 true로 바꾸어 한번더를 실행.

```jsx
componentDidMount(){
    const {winNumbers} = this.state;
    for(let i=0;i<this.state.winNumbers.length-1;i++){
      setTimeout(()=>{
        this.setState(()=>{
          return {
            winBalls: [...prevState.winBalls, winNumbers[i]]
          }
        })
      }, (i+1)*1000)
    }
    
    setTimeout(()=>{ // 보너스
      this.setState({
        bonus: winNumbers[6],
        redo: true,
      });
    }, 7000)
  }
```

>  ❗ 참고
>
> `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`
>
> 이 3가지는 사용X. 사라질 예정.
>
> 렌더링 전에 일어나던 라이프사이클 함수였다고 알고있으면 된다.



setTimeout이 여러개니까 timeout배열을 만들어 담아주고, `componentWillUnmount`에서 정리해주자. (메모리누수방지)

```jsx
componentDidMount(){
    const {winNumbers} = this.state;
    for(let i=0;i<this.state.winNumbers.length-1;i++){
        this.timeouts[i] = setTimeout(()=>{
            this.setState(()=>{
                return {
                    winBalls: [...prevState.winBalls, winNumbers[i]]
                }
            })
        }, (i+1)*1000)
    }
    setTimeout(()=>{ // 보너스
        this.setState({
            bonus: winNumbers[6],
            redo: true,
        });
    }, 7000)
}

componentWillUnmount(){
    this.timeouts.forEach((v)=>{
      clearTimeout(v);
    })
  }
```



**수정 사항**

실행해보면, 한번 더 버튼이 처음부터 보여져있다.

onClick에 3항연산자가 아닌, button에 조건문을 사용.

```jsx
render(){
    const {winBalls, bonus, redo} = this.state;
    return (
      <>
        <div>당첨 숫자</div>
        <div id="결과창">
          {winBalls.map((v)=> <Ball key={v} number={v} />)}
        </div>
        <div>보너스</div>
        {bonus && <Ball number={bonus} />}
        {redo && <button onClick={this.onClickRedo}>한 번 더!</button>}
      </>
    )
  }
```





## 06-03. componentDidUpdate

버튼의 클릭 메서드인 onClickRedo 작성

```jsx
onClickRedo = () =>{ // 처음 상태로 초기화
    this.setState({
        winNumbers: getWinNumbers(), // 당첨 숫자들
        winBalls: [],
        bonus: null, // 보너스 공
        redo: false,
    })
    this.timeouts = [];
}
```



버튼을 누르게 되면, `componentDidMount`의 메서드가 다시 실행되야한다.

**`componentDidUpdate`를 사용해보자.**

초기화 하면, winNumbers, winBalls, ... 등이 바뀌는데 `componentDidUpdate`에서 어떤게 바뀌었는지 판단할 수 있다.

```jsx
componentDidUpdate(prevProps, prevState){ ... }
```

바뀌기 전의 state가 **prevState**,  바뀐 후의 state는 **this.state**에 들어있다.

winBalls가 빌 때 다시 실행하도록 해주자.

```jsx
runTimeouts = () =>{
    const {winNumbers} = this.state;
    for(let i=0;i<this.state.winNumbers.length-1;i++){
        this.timeouts[i] = setTimeout(()=>{
            this.setState(()=>{
                return {
                    winBalls: [...prevState.winBalls, winNumbers[i]]
                }
            })
        }, (i+1)*1000)
    }
    setTimeout(()=>{ // 보너스
        this.setState({
            bonus: winNumbers[6],
            redo: true,
        });
    }, 7000)
}

componentDidUpdate(prevProps, prevState){
    if(this.state.winballs.length ===0){
        this.runTimeouts();
    }
}


componentDidMount(){
    this.runTimeouts();
}
```

조건을 걸어주지않으면, state가 바뀔때마다 `compnoentDidUpdate`가 동작하기 때문에 분기를 잘 해주어야한다.

각 메서드에 console을 찍어서 어떻게 실행되는지 확인!



## 06-04. useEffect로 업데이트 감지하기

## 06-05. useMemo와 useCallback

## 06-06. Hooks에 대한 자잘한 팁들





